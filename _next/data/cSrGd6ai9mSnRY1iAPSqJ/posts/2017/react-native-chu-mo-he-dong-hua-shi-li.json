{"pageProps":{"id":["2017","react-native-chu-mo-he-dong-hua-shi-li"],"name":"react-native触摸和动画实例","data":{"date":"2017-05-06","outdate":"","body":"实现的效果如下\n\n![GIF.gif](http://upload-images.jianshu.io/upload_images/864719-8082619733c970cc.gif?imageMogr2/auto-orient/strip)\n\n主要结合了 react-native 的触摸和动画事件，可通过点击和滑动进行操作。\n\n###组件结构\n四个滑块是由父组件 map 而来，因此只分析一个。以 touch 部分在左边为标准，滑块结构如下\n\n```js\n<View style={styles.container}>\n  <Animated.View\n    style={[\n      styles.touch,\n      {\n        transform: [{ translateX: this._animatedValue.x }],\n      },\n    ]}\n  ></Animated.View>\n  <View style={styles.card}></View>\n</View>\n```\n\n实质上只是分成了左右结构，左边的 touch 较为特殊，因为要实现动画效果，由动画组件代替。\n想用动画实现什么属性进行变化可通过在 style 中对该属性的值用 Animated.Value()进行初始化。比如想让 touch 的宽度用动画进行变化， 便可初始化宽度为`width: new Animated.Value(0)`.\n\n### 开始\n\n起初，没有引入动画，将 touch 定位设置为 relative，在触摸事件中监听其 onLayout，通过 setState 实时刷新位置，代码实现见[这一版](https://github.com/17forever/ELTD/commit/bc79e3ca5454dcfe3325020b1ae7eb3f51bd9a4a#diff-b66cfaf949cce4c0be5b5af71cd1de1d)。\n为了性能，为了交互，也为了折腾，引入 Animated 与 PanResponder，让这两个好基友一起做点什么。\n\n> 关于 Animated 和 PanResponder 的详细介绍可查看本文底部讲得非常好的参考链接，下面说实现。\n\n#### constructor\n\n```js\n  constructor(props) {\n    super(props);\n    this.state = {\n      isTouch: false, // 是否处于点击状态\n      blockInLeft: true, // touch是否在左侧\n    }\n\n    this._containerWidth = null; //滑块组件宽度，可在render内通过onLayout得到\n    this._touchBlockWidth = null; //touch宽度\n    this._touchTimeStamp = null; // 为不允许双击事件发生设置的一个当前点击时间点\n\n    this._startAnimation = this._startAnimation.bind(this)\n\n    this._animatedDivisionValue = new Animated.Value(0); //初始化动画值\n  }\n```\n\n#### 触摸事件注册\n\n```js\n  componentWillMount() {\n    this._animatedValue = new Animated.ValueXY()\n    this._value = {x: 0}\n    // 这里为了监听后面动画事件中setValue的值\n    this._animatedValue.addListener((value) => this._value = value);\n    this._panResponder = PanResponder.create({\n    // 写法基本是固定的\n      onStartShouldSetPanResponder: this._handleStartShouldSetPanResponder.bind(this),\n      onMoveShouldSetPanResponder: this._handleMoveShouldSetPanResponder.bind(this),\n      onPanResponderGrant: this._handlePanResponderGrant.bind(this),\n      onPanResponderMove: this._handlePanResponderMove.bind(this),\n      onPanResponderRelease: this._handlePanResponderEnd.bind(this),\n      onPanResponderTerminate: this._handlePanResponderEnd.bind(this),\n      });\n  }\n```\n\n#### 与动画的结合\n\n```js\n _handleStartShouldSetPanResponder(e, gestureState){\n    // 避免双击，与上次点击在500ms以内时不处理点击事件\n    const tick = new Date().getTime();\n    if (tick - this._touchTimeStamp < 500) {\n      return false;\n    }\n    this._touchTimeStamp = tick;\n    return true;\n  }\n  _handleMoveShouldSetPanResponder(e, gestureState){\n    // 是否响应移动事件\n    return true;\n  }\n  _handlePanResponderGrant(e, gestureState){\n    // touch告诉事件处理器，有人把手放我身上了\n    this.setState({\n      isTouch: true\n    })\n    // 归位\n    this._animatedValue.setOffset({x: this._value.x});\n    this._animatedValue.setValue({x: 0});\n  }\n\n  _handlePanResponderMove(e, gestureState) {\n    // 这个方法在手指移动过程中连续调用\n\n    // 计算滑块组件减去touch部分剩余的宽度，可写在外部\n    let canTouchLength = this._containerWidth - this._touchBlockWidth\n\n    // 在边界处不可向己边滑动。祥看下面endValue介绍\n    if ( (this.state.blockInLeft && gestureState.dx > 0 && gestureState.dx < canTouchLength) || (!this.state.blockInLeft && gestureState.dx < 0 && gestureState.dx > -canTouchLength) ) {\n\n      // 动画跟随触摸移动的关键，触摸动画实现的核心所在。只有在符合上述条件下touch才进行移动。\n      this._animatedValue.setValue({x: gestureState.dx})\n    }\n\n    // 如果不需要边界处理，也可用event代替setValue\n    // Animated.event([\n    //     null, {dx: this._animatedValue.x}\n    // ])\n  }\n\n  _handlePanResponderEnd(e, gestureState){\n  // 这个方法在手指离开屏幕时调用\n\n    // 同上，代码冗余，建议写在外部\n    let canTouchLength = this._containerWidth - this._touchBlockWidth\n\n    // 偏移。moveDistance计算touch的偏移值，判断其不等于0是为了处理点击操作\n    // gestureState.moveX有移动才会有值，点击的话值为0\n    let moveDistance = gestureState.moveX !== 0 ? gestureState.moveX - gestureState.x0 : 0;\n\n\n    // 确定移动方向。moveDistance大于0时代表touch向右移动，不管在左边还是右边\n    const toRight = moveDistance>0 ? true : false;\n\n    // 取移动距离\n    moveDistance = Math.abs(moveDistance)\n\n    // 设定个中间值决定滑块最终移向哪边。中间值为滑块宽度减去touch宽度的一半\n    const middleValue = canTouchLength / 2\n\n    // endValue为以左边为原点，最终移动位置相对于左边的距离。\n    // 这里为了实现触摸时如果没有将touch移动到最大位置释放操作，touch最终选择移动到左边还是右边\n    // 所以，向右移动touch时，中点以前为0，过了中点endValue为最大值\n    // 再向左移动时，中点以前为0（即不移动），过了中点为最大值的反向\n    // 这里还有个问题，touch的偏移实现上，是有累加性的。\n    // 即比如先向右移动touch到最大值，0 + maxValue，实现这个操作后，滑块所处的位置maxValue会重设为0\n    // 如果想移回来到左边，就需要0 - maxValue，这便是偏移的累加性\n    let endValue = 0\n\n    // 防止touch会被鼠标拽出边界，给第二个条件加上 this.state.blockInLeft 的判断\n    if ( (this.state.blockInLeft && moveDistance === 0) || (toRight && this.state.blockInLeft && (moveDistance > middleValue)) ) {\n      // touch向右移动时过了中点，或者touch在左边时，被单击\n      endValue = canTouchLength\n      this.setState({\n        blockInLeft: false\n      })\n    } else if ( (!this.state.blockInLeft && moveDistance === 0) || (!toRight && !this.state.blockInLeft && (moveDistance > middleValue)) ) {\n      // touch向左移动时过了中点，或者touch在右边时，被单击\n      endValue = -canTouchLength\n      this.setState({\n        blockInLeft: true\n      })\n    }\n\n    // touch到边界时会回弹的动画开始\n    this._startAnimation(endValue);\n\n    this.setState({\n      // 这人把手从我身上拿开了\n      isTouch:  false\n    })\n\n  }\n\n  _startAnimation(endValue) {\n    Animated.spring(this._animatedValue, {\n      toValue: endValue,\n      tension: 80\n    }).start(\n      () => {\n        // 这里本来想在动画结束后做一些事情，但是发现回调有些问题\n        // 可能是回弹的动画不一定会在touch移动的动画结束后触发\n      }\n    );\n  }\n```\n\n这是整个触摸与动画结合的实践。对于 touch 移动后另一边的信息也发生移动，可通过监听 touch 的 blockInLeft，用 margin 对另一边信息进行定位，这是我试过最简单而且没有副作用的方法。\n还想实现的一个功能是，随着 touch 从一边移动到另一边，底部文字的透明度从 1 -> 0 -> 1 这样切换。\n代码可以精简，性能还可以优化，先提供一个实现该功能的方法。欢迎拍砖指正，交流学习。\n\n### 参考文章\n\n- [React-Native 触摸与动画](http://xgfe.github.io/2016/08/21/lulutia/react-native-touch-animation/)\n- [「指尖上的魔法」- 谈谈 React Native 中的手势](https://juejin.im/entry/55fa202960b28497519db23f)\n- [React Native Animation Book](http://browniefed.com/react-native-animation-book/)\n  谢谢奉献"},"allPosts":[{"date":"2021","list":[{"name":"绩效约谈后有感","date":"2021-02-24","path":"ji-xiao-yue-tan-hou-you-gan","groupDate":"2021"},{"name":"面对人生选择","date":"2021-02-20","path":"mian-dui-ren-sheng-xuan-ze","groupDate":"2021"},{"name":"我的生日","date":"2021-01-27","path":"wo-de-sheng-ri","groupDate":"2021"},{"name":"2021年初的一点思考","date":"2021-01-20","path":"2021-nian-chu-de-yi-dian-si-kao","groupDate":"2021"}]},{"date":"2020","list":[{"name":"win10下使用wls2和vscode配置超级舒服的开发环境 ","date":"2020-11-29","path":"win10-xia-shi-yong-wls2-he-vscode-pei-zhi-chao-ji-shu-fu-de-kai-fa-huan-jing","groupDate":"2020"},{"name":"Termux玩法","date":"2020-10-19","path":"Termux-wan-fa","groupDate":"2020"},{"name":"nextjs-with-styled-components-fluent-ui","date":"2020-09-03","path":"nextjs-with-styled-components-fluent-ui","groupDate":"2020"},{"name":"脂肪肝","date":"2020-08-30","path":"zhi-fang-gan","groupDate":"2020"}]},{"date":"2018","list":[{"name":"两个口袋","date":"2018-05-06","path":"liang-ge-kou-dai","groupDate":"2018"}]},{"date":"2017","list":[{"name":"JavaScript50行代码暴力生成9x9数独","date":"2017-10-12","path":"JavaScript50-hang-dai-ma-bao-li-sheng-cheng-9x9-shu-du","groupDate":"2017"},{"name":"域名解析小记","date":"2017-09-23","path":"yu-ming-jie-xi-xiao-ji","groupDate":"2017"},{"name":"nginx作用","date":"2017-09-23","path":"nginx-zuo-yong","groupDate":"2017"},{"name":"linux nginx配置https笔记","date":"2017-09-23","path":"linux-nginx-pei-zhi-https-bi-ji","groupDate":"2017"},{"name":"React Material-UI笔记-theme篇","date":"2017-09-20","path":"React-Material-UI-bi-ji--theme-pian","groupDate":"2017"},{"name":"js异步之callback简述","date":"2017-07-07","path":"js-yi-bu-zhi-callback-jian-shu","groupDate":"2017"},{"name":"python爬虫初体验","date":"2017-06-03","path":"python-pa-chong-chu-ti-yan","groupDate":"2017"},{"name":"redux-saga简单入门使用","date":"2017-05-08","path":"redux-saga-jian-dan-ru-men-shi-yong","groupDate":"2017"},{"name":"react-native触摸和动画实例","date":"2017-05-06","path":"react-native-chu-mo-he-dong-hua-shi-li","groupDate":"2017"},{"name":"react技术栈学习","date":"2017-02-27","path":"react-ji-shu-zhan-xue-xi","groupDate":"2017"},{"name":"es6 export和import相关","date":"2017-02-26","path":"es6-export-he-import-xiang-guan","groupDate":"2017"},{"name":"canvas交互之addHitRegion()接口的使用","date":"2017-02-16","path":"canvas-jiao-hu-zhi-addHitRegion()-jie-kou-de-shi-yong","groupDate":"2017"}]},{"date":"2015","list":[{"name":"学车随笔","date":"2015-08-21","path":"xue-che-sui-bi","groupDate":"2015"},{"name":"怀念我的部长-刘高","date":"2015-04-10","path":"huai-nian-wo-de-bu-chang---liu-gao","groupDate":"2015"}]}],"datePosts":[{"name":"JavaScript50行代码暴力生成9x9数独","date":"2017-10-12","path":"JavaScript50-hang-dai-ma-bao-li-sheng-cheng-9x9-shu-du"},{"name":"域名解析小记","date":"2017-09-23","path":"yu-ming-jie-xi-xiao-ji"},{"name":"nginx作用","date":"2017-09-23","path":"nginx-zuo-yong"},{"name":"linux nginx配置https笔记","date":"2017-09-23","path":"linux-nginx-pei-zhi-https-bi-ji"},{"name":"React Material-UI笔记-theme篇","date":"2017-09-20","path":"React-Material-UI-bi-ji--theme-pian"},{"name":"js异步之callback简述","date":"2017-07-07","path":"js-yi-bu-zhi-callback-jian-shu"},{"name":"python爬虫初体验","date":"2017-06-03","path":"python-pa-chong-chu-ti-yan"},{"name":"redux-saga简单入门使用","date":"2017-05-08","path":"redux-saga-jian-dan-ru-men-shi-yong"},{"name":"react-native触摸和动画实例","date":"2017-05-06","path":"react-native-chu-mo-he-dong-hua-shi-li"},{"name":"react技术栈学习","date":"2017-02-27","path":"react-ji-shu-zhan-xue-xi"},{"name":"es6 export和import相关","date":"2017-02-26","path":"es6-export-he-import-xiang-guan"},{"name":"canvas交互之addHitRegion()接口的使用","date":"2017-02-16","path":"canvas-jiao-hu-zhi-addHitRegion()-jie-kou-de-shi-yong"}]},"__N_SSG":true}